//
//  electra.c
//  electra1131
//
//  Created by CoolStar on 6/6/18.
//  Copyright Â© 2018 CoolStar. All rights reserved.
//
#import <sys/stat.h>
#import <sys/utsname.h>
#import <dlfcn.h>


#include <assert.h>
#include <mach/mach.h>
#include <stdlib.h>
#include <unistd.h>
#include "electra.h"
#include "kutils.h"
#include "patchfinder64og.h"
//#include "../headers/QiLin.h"
//#include "proc_internal.h"
//#include "liboffsetfinder64.hpp"
//#include "patchfinder641.h"
#include "kexecute.h"
#include "codesign.h"
#include "offsetof.h"
#include "remap_tfp_set_hsp.h"
#include "unlocknvram.h"
#include "apfs_util.h"
#include "rootfs_remountog.h"
#include "electra_objc.h"
#include "bootstrap.h"
#include "file_utils.h"
#include "utils.h"
#include "nonce.h"
#include "unliberios.h"
#include "removePotentialJailbreak.h"
#include "detectConflictJailbreak.h"
#include "debug.h"
#include "amfi_utils.h"
#include "kernel_slide.h"
#include "parameters.h"
#include "kernel_memory.h"
#include "offsets.h"
#include "../headers/ipc_port.h"
#include "utilities/KernelMemory.h"
#include "../headers/kernelSymbolFinder.h"
#include "../headers/jelbrekLib.h"

#include "utilities/KernelUtilities.h"
#include "utilities/exploit_additions.h"

mach_port_t tfpzero = MACH_PORT_NULL;
#define uicache "/electra/uicache"
#define killall "/electra/killall"
#define TF_PLATFORM 0x00000400
#define ISADDR(val)            (val != 0 && val != HUGE_VAL && val != -HUGE_VAL)
#define ADDRSTRING(val)        [NSString stringWithFormat:@ADDR, val]
#define VROOT 0x000001 /* root of its file system */
#define VSYSTEM 0x000004 /* vnode being used by kernel */


bool acknowledgeSnapshotWarning = false;

void snapshotWarningRead(void){
    acknowledgeSnapshotWarning = true;
}

#define failIf(condition, message, ...) if (condition) {\
printf(message);\
goto end;\
}
#define maxVersion(v)  ([[[UIDevice currentDevice] systemVersion] compare:@v options:NSNumericSearch] != NSOrderedDescending)


int start_Th0r(mach_port_t tipsyPIEfp0, bool enable_tweaks){
    //printf("Starting Th0r running just a bit electra's code geeze...\n");
    runningpatches();
    int err = ERR_NOERR;

    if (tipsyPIEfp0 == MACH_PORT_NULL) {
        return ERR_TFP0;
    }
    tfpzero = tipsyPIEfp0;
   
    printf("[*] Starting fun");
    
    if (kCFCoreFoundationVersionNumber >= 1535.12) {
        printf("offsets selected for iOS 12.0 or above");
        
 //       v1ntex_offsets *v1ntex_offs = NULL;
        //if ((v1ntex_offs = get_v1ntex_offsets(kernelCachePath)) == NULL) {
        //    _assert(clean_file(kernelCacheDownloadedPath), message, true);
        //  _assert(false, message, true);
 //   }
 //   if (v1ntex(v1ntex_callback, NULL, v1ntex_offs) == ERR_SUCCESS &&{
        //MACH_PORT_VALID(tfp0) &&
        //kernel_base = find_kernel_base();//ISADDR(kernel_base) &&
        // kernel_slide;//ISADDR(kernel_slide)) {
        // exploit_success = true;
   //     }
   // )
        //break;
        //uint64_t kernel_base = find_kernel_base();
        //printf("[i] Kernel base: 0x%llx", kernel_base);
        //sleep(1);
        // Loads the kernel into the patch finder, which just fetches the kernel memory for patchfinder use
       // init_jelbrek(tfpzero);
        //init_with_kbase(tfpzero, _kernel_base__static_address_);
        //init_kernel(kernel_base, NULL);
        //sleep(1);
        
        // Get the slide
        //uint64_t slide = kernel_base - 0xFFFFFFF007004000;
       // printf("slide: 0x%016llx\n", slide);
        
        init_kexecute();
        //sleep(1);
        uint64_t kernel_map = MReadKernel64(kernel_task + OFFSET(task, map));
        printf("kernel_map is %llx\n", kernel_map);
        uint32_t our_pid = getpid();
        printf("our_pid is %d\n", our_pid);
        uint64_t our_proc = get_proc_struct_for_pid(our_pid);
        printf("our_proc is %llx\n", our_proc);
        uint64_t launchd_proc = (get_proc_struct_for_pid(1));
        printf("launchd_proc is %llx\n", launchd_proc);
        uint64_t kern_proc = get_proc_struct_for_pid(0);
        printf("kern_proc is %llx\n", kern_proc);
        uint32_t amfid_pid = find_pid_of_proc("amfid");
        uint64_t amfid_proc = get_proc_struct_for_pid(amfid_pid);
        printf("amfid_pid is %d\n", amfid_pid);
        printf("amfid_proc is %llx\n", amfid_proc);
        uint32_t cfprefsd_pid = find_pid_of_proc("cfprefsd");
        printf("cfprefsd_pid is %d\n", cfprefsd_pid);
        

        if (!our_proc || !launchd_proc || !kern_proc || !amfid_proc) {
            err = ERR_JAILBREAK;
            goto out;
        }
        
        printf("our proc is at 0x%016llx\n", our_proc);
        printf("launchd proc is at 0x%016llx\n", launchd_proc);
        printf("kern proc is at 0x%016llx\n", kern_proc);
        printf("amfid proc is at 0x%016llx\n", amfid_proc);
        
        
        uint32_t csflags;
        
        csflags = rk32(our_proc + offsetof_p_csflags);
        csflags = (csflags | CS_PLATFORM_BINARY | CS_INSTALLER | CS_GET_TASK_ALLOW) & ~(CS_RESTRICT | CS_HARD | CS_KILL);
        printf("csflags :0x%x\n", csflags);
        wk32(our_proc + offsetof_p_csflags, csflags);
        
        set_csblob(our_proc);
        
        csflags = rk32(launchd_proc + offsetof_p_csflags);
        wk32(launchd_proc + offsetof_p_csflags, (csflags | CS_PLATFORM_BINARY | CS_INSTALLER | CS_GET_TASK_ALLOW) & ~(CS_RESTRICT | CS_HARD));
        
        csflags = rk32(amfid_proc + offsetof_p_csflags);
        wk32(amfid_proc + offsetof_p_csflags, (csflags | CS_PLATFORM_BINARY | CS_INSTALLER | CS_GET_TASK_ALLOW) & ~(CS_RESTRICT | CS_HARD));
        
        
        if (find_pid_of_proc("jailbreakd")) {
            err = ERR_ALREADY_JAILBROKEN;
            goto out;
        }
        
        // Properly copy the kernel's credentials so setuid(0) doesn't crash
        
        uint64_t copyout = find_copyout();
        uint64_t bcopy = find_bcopy();
        uint64_t bzero = find_bzero();
        
        uint64_t kern_ucred = 0;
        kexecute(copyout, kern_proc+offsetof_p_ucred, (uint64_t)&kern_ucred, sizeof(kern_ucred), 0, 0, 0, 0);
        printf("copyout : 0x%llx\n", copyout);
        printf("bcopy : 0x%llx\n", bcopy);
        printf("bzero : 0x%llx\n", bzero);
        
        printf("kern_ucred : 0x%llx\n", kern_ucred);
        
    
        uint64_t self_ucred = 0;
        kexecute(copyout, our_proc+offsetof_p_ucred, (uint64_t)&self_ucred, sizeof(self_ucred), 0, 0, 0, 0);
        printf("self_ucred : 0x%llx\n", self_ucred);
        
        kexecute(bcopy, kern_ucred + 0x78, self_ucred + 0x78, sizeof(uint64_t), 0, 0, 0, 0);
        kexecute(bzero, self_ucred + 0x18, 12, 0, 0, 0, 0, 0);
        
        sleep(1);
        
        
        setuid(0);
        if (getuid()) {
            err = ERR_JAILBREAK;
            goto out;
        }
        
        
        printf("our uid is %d\n", getuid());
        
        // Test writing to file
        {
            FILE *f = fopen("/var/mobile/test.txt", "w");
            if (f == 0) {
                printf("failed to write test file");
            } else {
                printf("wrote test file: %p\n", f);
            }
            
            unlink("/var/mobile/test.txt");
        }
        if (!file_exists("/var/mobile/Media/th0rkcache/kernelcache")) {
            int rv2 = mkdir("/var/mobile/Media/th0rkcache", 0777);

            printf("Made directory for kerenlcache in /var/mobile/Media/th0rkcache: %d\n", rv2);
            sleep(1);
        }
        if (!file_exists("/var/mobile/Media/th0rkcache/kernelcache")) {
            int rv2 = cp( "/var/mobile/Media/th0rkcache/kernelcache", "/System/Library/Caches/com.apple.kernelcaches/kernelcache");
            printf("wrote kernelcache file to /var/mobile/Media/th0rkcache/: %d\n", rv2);
            sleep(1);
        }
        
        //       v1ntex_offsets *v1ntex_offs = NULL;
        //if ((v1ntex_offs = get_v1ntex_offsets(kernelCachePath)) == NULL) {
        //    _assert(clean_file(kernelCacheDownloadedPath), message, true);
        //  _assert(false, message, true);
        //   }
        //   if (v1ntex(v1ntex_callback, NULL, v1ntex_offs) == ERR_SUCCESS &&{
        //MACH_PORT_VALID(tfp0) &&
        //kernel_base = find_kernel_base();//ISADDR(kernel_base) &&
        // kernel_slide;//ISADDR(kernel_slide)) {
        // exploit_success = true;
        //     }
        // )
        
        init_jelbrek(tfpzero);

        initWithKernelCache("/var/mobile/Media/th0rkcache/kernelcache");
        sleep(1);
        
        //---- host special port 4 ----//
        
        failIf(setHSP4(), "[-] Failed to set tfp0 as hsp4!");
        PatchHostPriv(mach_host_self());
        
        
        //---- nvram ----//
        // people say that this ain't stable
        // and that ya should lock it later
        // but, I haven't experienced issues
        // nor so rootlessJB people
        UnlockNVRAM();
        sleep(1);
        
        
        
        //remountRootFS();
        
        printf("Mounted volumes:\n");
        printf("\n");
        
        int forkAndRunMount = fork();
        if (forkAndRunMount > 0){
            waitpid(forkAndRunMount, NULL, 0);
        } else if (forkAndRunMount == 0){
            const char *args_mount[] = {"mount", NULL};
            execv("/sbin/mount", (char **)&args_mount);
            printf("Child should never reach here!\n");
            exit(-1);
        } else {
            printf("Unable to fork!\n");
        }
        
        int ret;
        
        // Only set a generator if one is not already set or if the user has specified one
        const char *currentgen = getgen();
        if (!currentgen || userGenerator()) {
            const char *gen = genToSet();
            // Only actually set the generator if it is not already set
            if (!currentgen || strcasecmp(currentgen, gen) != 0) {
                //printf("Setting generator to %s\n", gen);
                ret = setgen(gen);
                //printf("ret: %d\n", ret);
            } else {
                //printf("Requested generator already set: %s\n", gen);
            }
        }
        
        int forkAndRunNVRAM = fork();
        if (forkAndRunNVRAM > 0){
            waitpid(forkAndRunNVRAM, NULL, 0);
        } else if (forkAndRunNVRAM == 0){
            const char *args_nvram[] = {"nvram", "-p", NULL};
            execv("/usr/sbin/nvram", (char **)&args_nvram);
            printf("Child should never reach here!\n");
            exit(-1);
        } else {
            printf("Unable to fork!\n");
        }
        LockNVRAM();
        
        printf("APFS Snapshots: \n");
        printf("=========\n");
        
        int snapshot_success = list_snapshots("/");
        printf("=========\n");
        
        ret = remountRootFS();//remountRootAsRW(slide, kern_proc, our_proc, snapshot_success);
        
        if (ret != 0) {
            err = ERR_ROOTFS_REMOUNT;
            goto out;
        }
        
        
        printf("Remounting RootFS...");
        copy_basebinaries();
        
        forkAndRunMount = fork();
        if (forkAndRunMount > 0){
            waitpid(forkAndRunMount, NULL, 0);
        } else if (forkAndRunMount == 0){
            const char *args_mount[] = {"mount", NULL};
            execv("/sbin/mount", (char **)&args_mount);
            printf("Child should never reach here!\n");
            exit(-1);
        } else {
            printf("Unable to fork!\n");
        }
        
        dumpContentsOfDir("/");
        dumpContentsOfDir("/electra");
        
#define BinaryLocation "/electra/inject_criticald"
        
        int rv;
        pid_t pd;
        
        const char* args_amfid[] = {BinaryLocation, itoa(amfid_pid), "/electra/amfid_payload.dylib", NULL};
        rv = posix_spawn(&pd, BinaryLocation, NULL, NULL, (char **)&args_amfid, NULL);
        waitpid(pd, NULL, 0);
        
        unlink("/.amfid_success");
        const char *args_helloworld[] = {"helloworld", NULL};
        rv = posix_spawn(&pd, "/electra/helloworld", NULL, NULL, (char **)&args_helloworld, NULL);
        waitpid(pd, NULL, 0);
        
        if (!file_exists("/.amfid_success")){
            printf("amfid injection fail!\n");
            return ERR_AMFID_PATCH;
        }
        unlink("/.amfid_success");
        
        //
        if (checkingJUSTremovecheck()==TRUE){
            int bootstrapped = open("/var/mobile/Media/.bootstrapped_electraRemover", O_RDONLY);
            printf("[*****] REMOVER working!\n");
            if (snapshot_success == 0 && kCFCoreFoundationVersionNumber <= 1451.51){
                if (bootstrapped == -1) {
                    int snapshot = check_snapshot("/", "electra-prejailbreak");
                    if (snapshot == 1){
                        printf("Snapshot exists!\n");
                    } else if (snapshot == 0){
                        rename("/electra/createSnapshot", "/createSnapshot");
                        pid_t pd;
                        rmdir("/electra");
                        
                        rv = posix_spawn(&pd, "/createSnapshot", NULL, NULL, (char **)&(const char*[]){ "createSnapshot", NULL }, NULL);
                        waitpid(pd, NULL, 0);
                        
                        printf("APFS Snapshots: \n");
                        
                        printf("=========\n");
                        list_snapshots("/");
                        printf("=========\n");
                        
                        snapshot = check_snapshot("/", "electra-prejailbreak");
                        if (snapshot != 1){
                            err = ERR_SNAPSHOT;
                            goto out;
                        }
                        
                        acknowledgeSnapshotWarning = false;
                        displaySnapshotNotice();
                        while (!acknowledgeSnapshotWarning){
                            usleep(1000000);
                        }
                        
                        copy_basebinaries();
                    }
                } else {
                    int snapshot = check_snapshot("/", "electra-prejailbreak");
                    if (snapshot != 1){
                        if (!file_exists("/.electra_no_snapshot")){
                            acknowledgeSnapshotWarning = false;
                            displaySnapshotWarning();
                            while (!acknowledgeSnapshotWarning){
                                usleep(1000000);
                            }
                            int rv = open("/.electra_no_snapshot", O_RDWR|O_CREAT);
                            close(rv);
                        }
                    }
                }
            }
            
            close(bootstrapped);
            
        }else {
            int bootstrapped = open("/.bootstrapped_Th0r", O_RDONLY);
            
            if (bootstrapped == -1) {
                if (checkLiberiOS() == true) {
                    removingLiberiOS();
                    removeLiberiOS();
                }
#if ELECTRADEBUG
#else /* !ELECTRADEBUG */
                if (detectConflictJailbreak()) {
                    err = ERR_CONFLICT;
                    goto out;
                }
#endif /* !ELECTRADEBUG */
                removePotentialJailbreak();
            }
            if (snapshot_success == 0 && kCFCoreFoundationVersionNumber <= 1451.51){
                if (bootstrapped == -1) {
                    int snapshot = check_snapshot("/", "electra-prejailbreak");
                    if (snapshot == 1){
                        printf("Snapshot exists!\n");
                    } else if (snapshot == 0){
                        rename("/electra/createSnapshot", "/createSnapshot");
                        pid_t pd;
                        rmdir("/electra");
                        
                        rv = posix_spawn(&pd, "/createSnapshot", NULL, NULL, (char **)&(const char*[]){ "createSnapshot", NULL }, NULL);
                        waitpid(pd, NULL, 0);
                        
                        printf("APFS Snapshots: \n");
                        
                        printf("=========\n");
                        list_snapshots("/");
                        printf("=========\n");
                        
                        snapshot = check_snapshot("/", "electra-prejailbreak");
                        if (snapshot != 1){
                            err = ERR_SNAPSHOT;
                            goto out;
                        }
                        
                        acknowledgeSnapshotWarning = false;
                        displaySnapshotNotice();
                        while (!acknowledgeSnapshotWarning){
                            usleep(1000000);
                        }
                        
                        copy_basebinaries();
                    }
                } else {
                    int snapshot = check_snapshot("/", "electra-prejailbreak");
                    if (snapshot != 1){
                        if (!file_exists("/.electra_no_snapshot")){
                            acknowledgeSnapshotWarning = false;
                            displaySnapshotWarning();
                            while (!acknowledgeSnapshotWarning){
                                usleep(1000000);
                            }
                            int rv = open("/.electra_no_snapshot", O_RDWR|O_CREAT);
                            close(rv);
                        }
                    }
                }
            }
            
            close(bootstrapped);
            
            
        }
        
        
        
        
        printf("Running mount...\n");
        //rmounting();
        term_kexecute();
        //almostdone();
        
        //---- bootstrap ----//
        extract_bootstrap();
        serverS();
        printf("Starting server...\n");
        //serverS();
        
        
        
        
        
        if (checkingJUSTremovecheck()==TRUE){
            
            printf("[*****] FUCK REMOVER IS GETTING CLOSER!\n");
            
            
        }else {
            uint64_t kernel_base = find_kernel_base();
            ////////////////remover block
            start_jailbreakd(kernel_base);
            //wait4jailbreakd();
            while (!file_exists("/var/run/jailbreakd.pid")){
                //printf("Waiting for jailbreakd...\n");
                //sleep(2); //100 ms
                usleep(100000);//10 ms
                
            }
            
            ////////////////remover block
            
        }

        unlink("/electra/createSnapshot");
        unlink("/electra/rm");
        
        update_springboard_plist();
        //sleep(1);
        
        
        if (checkingJUSTremovecheck()==TRUE){
            
            printf("[*****] FUCK REMOVER IS GETTING CLOSER!\n");
            
            
        }else {
            ////////////////remover block
            kill(cfprefsd_pid, SIGKILL);
            ////////////////remover block
            
        }
        
        
        
        //waittermkernel();
        //waittermkernel();
        term_kernel();
        
        if (checkingJUSTremovecheck()==TRUE){
            
            printf("[*****] FUCK REMOVER IS GETTING CLOSER!\n");
            
            
        }else {
            ////////////////remover block
            
            while (!file_exists("/electra/pspawn_payload.dylib")){
                usleep(10);
            }
            //waitkerneldone();
            run(""BinaryLocation" 1 /electra/pspawn_payload.dylib");
            
            if (enable_tweaks){
                startdwait();
                startDaemons();
                posix_spawn(&pd, "/electra/killall", NULL, NULL, (char **)&(const char*[]){ "/electra/killall", "SpringBoard", NULL }, NULL);
                //   posix_spawn(&pd, "/electra/killall", NULL, NULL, (char **)&(const char*[]){ "/electra/killall", "backboardd", NULL }, NULL);
                waitpid(pd, NULL, 0);
                
            }
            ////////////////remover block
        }
        
        /////////
        return err;
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        

        
        
        
        
        
        
        
        
    }else if (kCFCoreFoundationVersionNumber < 1535.12) {
        printf("kernel_base selected for iOS 11.0 - 11.4.1\n");
        
        //       v1ntex_offsets *v1ntex_offs = NULL;
        //if ((v1ntex_offs = get_v1ntex_offsets(kernelCachePath)) == NULL) {
        //    _assert(clean_file(kernelCacheDownloadedPath), message, true);
        //  _assert(false, message, true);
        //   }
        //   if (v1ntex(v1ntex_callback, NULL, v1ntex_offs) == ERR_SUCCESS &&{
        //MACH_PORT_VALID(tfp0) &&
        //kernel_base = find_kernel_base();//ISADDR(kernel_base) &&
        // kernel_slide;//ISADDR(kernel_slide)) {
        // exploit_success = true;
        //     }
        // )
        
        //return ERR_VERSION;
        
        
            if (!file_exists("/var/mobile/Media/th0rkcache/kernelcache")) {
                int rv2 = mkdir("/var/mobile/Media/th0rkcache", 0777);
                
                printf("Made directory for kerenlcache in /var/mobile/Media/th0rkcache: %d\n", rv2);
                sleep(1);
            }
            if (!file_exists("/var/mobile/Media/th0rkcache/kernelcache")) {
                int rv2 = cp( "/var/mobile/Media/th0rkcache/kernelcache", "/System/Library/Caches/com.apple.kernelcaches/kernelcache");
                printf("wrote kernelcache file to /var/mobile/Media/th0rkcache/: %d\n", rv2);
                sleep(1);
            }
            uint64_t kernel_base = find_kernel_base();
            printf("[i] Kernel base: 0x%llx", kernel_base);
            //sleep(1);
            
            init_kernel(kernel_base, NULL);//Loads kernel into the patch finder, which just fetches the kernel memory for patchfinder use
            //sleep(1);
            uint64_t slide = kernel_base - 0xFFFFFFF007004000;// Get the slide
            printf("slide: 0x%016llx\n", slide);
            init_kexecute();
            //sleep(1);
            uint64_t kernel_map = //MReadKernel64(kernel_task + OFFSET(task, map));
            printf("kernel_map is %llx\n", kernel_map);
            uint32_t our_pid = getpid();
            printf("our_pid is %d\n", our_pid);
            uint64_t our_proc = get_proc_struct_for_pid(our_pid);
            printf("our_proc is %llx\n", our_proc);
            uint64_t launchd_proc = (get_proc_struct_for_pid(1));
            printf("launchd_proc is %llx\n", launchd_proc);
            uint64_t kern_proc = get_proc_struct_for_pid(0);
            printf("kern_proc is %llx\n", kern_proc);
            uint32_t amfid_pid = find_pid_of_proc("amfid");
            uint64_t amfid_proc = get_proc_struct_for_pid(amfid_pid);
            printf("amfid_pid is %d\n", amfid_pid);
            printf("amfid_proc is %llx\n", amfid_proc);
            uint32_t cfprefsd_pid = find_pid_of_proc("cfprefsd");
            printf("cfprefsd_pid is %d\n", cfprefsd_pid);
            
        end:
            if (!our_proc || !launchd_proc || !kern_proc || !amfid_proc) {
                err = ERR_JAILBREAK;
                goto out;
            }
            
            printf("our proc is at 0x%016llx\n", our_proc);
            printf("launchd proc is at 0x%016llx\n", launchd_proc);
            printf("kern proc is at 0x%016llx\n", kern_proc);
            printf("amfid proc is at 0x%016llx\n", amfid_proc);
            
            
            uint32_t csflags;
            
            csflags = rk32(our_proc + offsetof_p_csflags);
            csflags = (csflags | CS_PLATFORM_BINARY | CS_INSTALLER | CS_GET_TASK_ALLOW) & ~(CS_RESTRICT | CS_HARD | CS_KILL);
            printf("csflags :0x%x\n", csflags);
            wk32(our_proc + offsetof_p_csflags, csflags);
            
            set_csblob(our_proc);
            
            csflags = rk32(launchd_proc + offsetof_p_csflags);
            wk32(launchd_proc + offsetof_p_csflags, (csflags | CS_PLATFORM_BINARY | CS_INSTALLER | CS_GET_TASK_ALLOW) & ~(CS_RESTRICT | CS_HARD));
            
            csflags = rk32(amfid_proc + offsetof_p_csflags);
            wk32(amfid_proc + offsetof_p_csflags, (csflags | CS_PLATFORM_BINARY | CS_INSTALLER | CS_GET_TASK_ALLOW) & ~(CS_RESTRICT | CS_HARD));
            
            
            if (find_pid_of_proc("jailbreakd")) {
                err = ERR_ALREADY_JAILBROKEN;
                goto out;
            }
            
            // Properly copy the kernel's credentials so setuid(0) doesn't crash
            
            uint64_t copyout = find_copyout();
            uint64_t bcopy = find_bcopy();
            uint64_t bzero = find_bzero();
            
            uint64_t kern_ucred = 0;
            kexecute(copyout, kern_proc+offsetof_p_ucred, (uint64_t)&kern_ucred, sizeof(kern_ucred), 0, 0, 0, 0);
            printf("copyout : 0x%llx\n", copyout);
            printf("bcopy : 0x%llx\n", bcopy);
            printf("bzero : 0x%llx\n", bzero);
            
            printf("kern_ucred : 0x%llx\n", kern_ucred);
            
            
            uint64_t self_ucred = 0;
            kexecute(copyout, our_proc+offsetof_p_ucred, (uint64_t)&self_ucred, sizeof(self_ucred), 0, 0, 0, 0);
            printf("self_ucred : 0x%llx\n", self_ucred);
            
            kexecute(bcopy, kern_ucred + 0x78, self_ucred + 0x78, sizeof(uint64_t), 0, 0, 0, 0);
            kexecute(bzero, self_ucred + 0x18, 12, 0, 0, 0, 0, 0);
            
            sleep(1);
            
            
            setuid(0);
            if (getuid()) {
                err = ERR_JAILBREAK;
                goto out;
            }
            
            
            printf("our uid is %d\n", getuid());
            
            // Test writing to file
            {
                FILE *f = fopen("/var/mobile/test.txt", "w");
                if (f == 0) {
                    printf("failed to write test file");
                } else {
                    printf("wrote test file: %p\n", f);
                }
                
                unlink("/var/mobile/test.txt");
            }
            mkdir("/var/mobile/Media/th0rkcache", 0777);
            
            int rv2 = cp( "/var/mobile/Media/th0rkcache/kernelcache", "/System/Library/Caches/com.apple.kernelcaches/kernelcache");
            printf("wrote kernelcache file: %d\n", rv2);
            sleep(1);
            
            
            init_jelbrek(tfpzero);
            
            initWithKernelCache("/var/mobile/Media/th0rkcache/kernelcache");
            sleep(1);
            
            //---- host special port 4 ----//
            
            failIf(setHSP4(), "[-] Failed to set tfp0 as hsp4!");
            PatchHostPriv(mach_host_self());
            
            
            //---- nvram ----//
            // people say that this ain't stable
            // and that ya should lock it later
            // but, I haven't experienced issues
            // nor so rootlessJB people
            UnlockNVRAM();
            sleep(1);
            
            
            
            //remountRootFS();
            
            printf("Mounted volumes:\n");
            printf("\n");
            
            int forkAndRunMount = fork();
            if (forkAndRunMount > 0){
                waitpid(forkAndRunMount, NULL, 0);
            } else if (forkAndRunMount == 0){
                const char *args_mount[] = {"mount", NULL};
                execv("/sbin/mount", (char **)&args_mount);
                printf("Child should never reach here!\n");
                exit(-1);
            } else {
                printf("Unable to fork!\n");
            }
            
            int ret;
            
            // Only set a generator if one is not already set or if the user has specified one
            const char *currentgen = getgen();
            if (!currentgen || userGenerator()) {
                const char *gen = genToSet();
                // Only actually set the generator if it is not already set
                if (!currentgen || strcasecmp(currentgen, gen) != 0) {
                    //printf("Setting generator to %s\n", gen);
                    ret = setgen(gen);
                    //printf("ret: %d\n", ret);
                } else {
                    //printf("Requested generator already set: %s\n", gen);
                }
            }
            
            int forkAndRunNVRAM = fork();
            if (forkAndRunNVRAM > 0){
                waitpid(forkAndRunNVRAM, NULL, 0);
            } else if (forkAndRunNVRAM == 0){
                const char *args_nvram[] = {"nvram", "-p", NULL};
                execv("/usr/sbin/nvram", (char **)&args_nvram);
                printf("Child should never reach here!\n");
                exit(-1);
            } else {
                printf("Unable to fork!\n");
            }
            LockNVRAM();
            
            printf("APFS Snapshots: \n");
            printf("=========\n");
            
            int snapshot_success = list_snapshots("/");
            printf("=========\n");
            
            ret = remountRootAsRW(slide, kern_proc, our_proc, snapshot_success);
            
            if (ret != 0) {
                err = ERR_ROOTFS_REMOUNT;
                goto out;
            }
            
            
            printf("Remounting RootFS...");
            copy_basebinaries();
            
            forkAndRunMount = fork();
            if (forkAndRunMount > 0){
                waitpid(forkAndRunMount, NULL, 0);
            } else if (forkAndRunMount == 0){
                const char *args_mount[] = {"mount", NULL};
                execv("/sbin/mount", (char **)&args_mount);
                printf("Child should never reach here!\n");
                exit(-1);
            } else {
                printf("Unable to fork!\n");
            }
            
            dumpContentsOfDir("/");
            dumpContentsOfDir("/electra");
            
#define BinaryLocation "/electra/inject_criticald"
            
            int rv;
            pid_t pd;
            
            const char* args_amfid[] = {BinaryLocation, itoa(amfid_pid), "/electra/amfid_payload.dylib", NULL};
            rv = posix_spawn(&pd, BinaryLocation, NULL, NULL, (char **)&args_amfid, NULL);
            waitpid(pd, NULL, 0);
            
            unlink("/.amfid_success");
            const char *args_helloworld[] = {"helloworld", NULL};
            rv = posix_spawn(&pd, "/electra/helloworld", NULL, NULL, (char **)&args_helloworld, NULL);
            waitpid(pd, NULL, 0);
            
            if (!file_exists("/.amfid_success")){
                printf("amfid injection fail!\n");
                return ERR_AMFID_PATCH;
            }
            unlink("/.amfid_success");
            
            //
            if (checkingJUSTremovecheck()==TRUE){
                int bootstrapped = open("/var/mobile/Media/.bootstrapped_electraRemover", O_RDONLY);
                printf("[*****] REMOVER working!\n");
                if (snapshot_success == 0 && kCFCoreFoundationVersionNumber <= 1451.51){
                    if (bootstrapped == -1) {
                        int snapshot = check_snapshot("/", "electra-prejailbreak");
                        if (snapshot == 1){
                            printf("Snapshot exists!\n");
                        } else if (snapshot == 0){
                            rename("/electra/createSnapshot", "/createSnapshot");
                            pid_t pd;
                            rmdir("/electra");
                            
                            rv = posix_spawn(&pd, "/createSnapshot", NULL, NULL, (char **)&(const char*[]){ "createSnapshot", NULL }, NULL);
                            waitpid(pd, NULL, 0);
                            
                            printf("APFS Snapshots: \n");
                            
                            printf("=========\n");
                            list_snapshots("/");
                            printf("=========\n");
                            
                            snapshot = check_snapshot("/", "electra-prejailbreak");
                            if (snapshot != 1){
                                err = ERR_SNAPSHOT;
                                goto out;
                            }
                            
                            acknowledgeSnapshotWarning = false;
                            displaySnapshotNotice();
                            while (!acknowledgeSnapshotWarning){
                                usleep(1000000);
                            }
                            
                            copy_basebinaries();
                        }
                    } else {
                        int snapshot = check_snapshot("/", "electra-prejailbreak");
                        if (snapshot != 1){
                            if (!file_exists("/.electra_no_snapshot")){
                                acknowledgeSnapshotWarning = false;
                                displaySnapshotWarning();
                                while (!acknowledgeSnapshotWarning){
                                    usleep(1000000);
                                }
                                int rv = open("/.electra_no_snapshot", O_RDWR|O_CREAT);
                                close(rv);
                            }
                        }
                    }
                }
                
                close(bootstrapped);
                
            }else {
                int bootstrapped = open("/.bootstrapped_Th0r", O_RDONLY);
                
                if (bootstrapped == -1) {
                    if (checkLiberiOS() == true) {
                        removingLiberiOS();
                        removeLiberiOS();
                    }
#if ELECTRADEBUG
#else /* !ELECTRADEBUG */
                    if (detectConflictJailbreak()) {
                        err = ERR_CONFLICT;
                        goto out;
                    }
#endif /* !ELECTRADEBUG */
                    removePotentialJailbreak();
                }
                if (snapshot_success == 0 && kCFCoreFoundationVersionNumber <= 1451.51){
                    if (bootstrapped == -1) {
                        int snapshot = check_snapshot("/", "electra-prejailbreak");
                        if (snapshot == 1){
                            printf("Snapshot exists!\n");
                        } else if (snapshot == 0){
                            rename("/electra/createSnapshot", "/createSnapshot");
                            pid_t pd;
                            rmdir("/electra");
                            
                            rv = posix_spawn(&pd, "/createSnapshot", NULL, NULL, (char **)&(const char*[]){ "createSnapshot", NULL }, NULL);
                            waitpid(pd, NULL, 0);
                            
                            printf("APFS Snapshots: \n");
                            
                            printf("=========\n");
                            list_snapshots("/");
                            printf("=========\n");
                            
                            snapshot = check_snapshot("/", "electra-prejailbreak");
                            if (snapshot != 1){
                                err = ERR_SNAPSHOT;
                                goto out;
                            }
                            
                            acknowledgeSnapshotWarning = false;
                            displaySnapshotNotice();
                            while (!acknowledgeSnapshotWarning){
                                usleep(1000000);
                            }
                            
                            copy_basebinaries();
                        }
                    } else {
                        int snapshot = check_snapshot("/", "electra-prejailbreak");
                        if (snapshot != 1){
                            if (!file_exists("/.electra_no_snapshot")){
                                acknowledgeSnapshotWarning = false;
                                displaySnapshotWarning();
                                while (!acknowledgeSnapshotWarning){
                                    usleep(1000000);
                                }
                                int rv = open("/.electra_no_snapshot", O_RDWR|O_CREAT);
                                close(rv);
                            }
                        }
                    }
                }
                close(bootstrapped);
            }
            
            printf("Running mount...\n");
            //rmounting();
            term_kexecute();
            //almostdone();
            
            //---- bootstrap ----//
            extract_bootstrap();
            serverS();
            printf("Starting server...\n");
            //serverS();
            if (checkingJUSTremovecheck()==TRUE){
                
                printf("[*****] FUCK REMOVER IS GETTING CLOSER!\n");
                
                
            }else {
                ////////////////remover block
                start_jailbreakd(kernel_base);
                //wait4jailbreakd();
                while (!file_exists("/var/run/jailbreakd.pid")){
                    //printf("Waiting for jailbreakd...\n");
                    //sleep(2); //100 ms
                    usleep(100000);//10 ms
                }
                ////////////////remover block
                
            }
            unlink("/electra/createSnapshot");
            unlink("/electra/rm");
            
            update_springboard_plist();
            //sleep(1);
            
            
            if (checkingJUSTremovecheck()==TRUE){
                
                printf("[*****] FUCK REMOVER IS GETTING CLOSER!\n");
                
                
            }else {
                ////////////////remover block
                kill(cfprefsd_pid, SIGKILL);
                ////////////////remover block
                
            }
            
            
            
            //waittermkernel();
            //waittermkernel();
            term_kernel();
            
            if (checkingJUSTremovecheck()==TRUE){
                
                printf("[*****] FUCK REMOVER IS GETTING CLOSER!\n");
                
                
            }else {
                ////////////////remover block
                
                while (!file_exists("/electra/pspawn_payload.dylib")){
                    usleep(10);
                }
                //waitkerneldone();
                run(""BinaryLocation" 1 /electra/pspawn_payload.dylib");
                
                if (enable_tweaks){
                    startdwait();
                    startDaemons();
                    posix_spawn(&pd, "/electra/killall", NULL, NULL, (char **)&(const char*[]){ "/electra/killall", "SpringBoard", NULL }, NULL);
                    //   posix_spawn(&pd, "/electra/killall", NULL, NULL, (char **)&(const char*[]){ "/electra/killall", "backboardd", NULL }, NULL);
                    waitpid(pd, NULL, 0);
                    
                }
                ////////////////remover block
            }
            
            /////////
        return err;
    }

out:
    term_jelbrek();
    term_kexecute();
    term_kernel();
    return err;
}
