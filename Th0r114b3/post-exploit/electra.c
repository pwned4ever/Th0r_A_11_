//
//  electra.c
//  electra1131
//
//  Created by CoolStar on 6/6/18.
//  Copyright Â© 2018 CoolStar. All rights reserved.
//

#include "electra.h"
#include "kutils.h"
#include "patchfinder64.h"
//#include "liboffsetfinder64.hpp"
//#include "offsetfinder64.hpp"

#include "kexecute.h"
#include "codesign.h"
#include "offsetof.h"
#include "remap_tfp_set_hsp.h"
#include "unlocknvram.h"
#include "apfs_util.h"
#include "rootfs_remount.h"
#include "electra_objc.h"
#include "bootstrap.h"
#include "file_utils.h"
#include "utils.h"
#include "nonce.h"
#include "unliberios.h"
#include "removePotentialJailbreak.h"
#include "detectConflictJailbreak.h"
#include "debug.h"
#include "amfi_utils.h"
#include "kernel_slide.h"
#include "parameters.h"
#include "voucher_swap.h"
#include "kernel_memory.h"
#include "offsets.h"
#include "utilities/KernelMemory.h"

#include "utilities/KernelUtilities.h"
#include "utilities/exploit_additions.h"
//#include "utilities/kutils.h"

mach_port_t tfpzero = MACH_PORT_NULL;
#define uicache "/electra/uicache"
#define killall "/electra/killall"
#define TF_PLATFORM 0x00000400
bool acknowledgeSnapshotWarning = false;

void snapshotWarningRead(void){
    acknowledgeSnapshotWarning = true;
}


static bool
stage1_check_kernel_task_port(uint64_t candidate_port, uint64_t *kernel_task_address) {
    // Check the ip_bits field.
    uint32_t ip_bits = MReadKernel32(candidate_port + OFFSET(ipc_port, ip_bits));

    // This is a task port. Get the task.
    uint64_t task = MReadKernel64(candidate_port + OFFSET(ipc_port, ip_kobject));
    // Now get the task's PID.
    uint64_t proc = MReadKernel64(task + OFFSET(task, bsd_info));
    uint32_t pid = MReadKernel32(proc + OFFSET(proc, p_pid));
    // The kernel task has pid 0.
    if (pid != 0) {
        return false;
    }
    // Found it!
    *kernel_task_address = task;
    return true;
}

static void
build_fake_kernel_task(void *data, uint64_t kernel_address,
                       size_t task_offset, size_t port_offset,
                       uint64_t ipc_space_kernel, uint64_t kernel_map) {
    // Create our fake kernel_task.
    uint8_t *fake_task = (uint8_t *) data + task_offset;
    uint64_t fake_task_address = kernel_address + task_offset;
    FIELD(fake_task, task, lck_mtx_type, uint8_t)  = 0x22;
    FIELD(fake_task, task, ref_count,    uint64_t) = 4;
    FIELD(fake_task, task, active,       uint32_t) = 1;
    FIELD(fake_task, task, map,          uint64_t) = kernel_map;
    // Initialize the port as a fake task port pointing to our fake kernel_task.
    uint8_t *fake_port_data = (uint8_t *) data + port_offset;
    //FIELD(fake_port_data, ipc_port, ip_bits,       uint32_t) = io_makebits(1, IOT_PORT, IKOT_TASK);
    FIELD(fake_port_data, ipc_port, ip_references, uint32_t) = 4;
    FIELD(fake_port_data, ipc_port, ip_receiver,   uint64_t) = ipc_space_kernel;
    FIELD(fake_port_data, ipc_port, ip_kobject,    uint64_t) = fake_task_address;
    FIELD(fake_port_data, ipc_port, ip_mscount,    uint32_t) = 1;
    FIELD(fake_port_data, ipc_port, ip_srights,    uint32_t) = 1;
}




int start_Th0r(mach_port_t tfp0, bool enable_tweaks){
    //printf("Starting Th0r running electra's code geeze...\n");
    
    int err = ERR_NOERR;
    
    if (tfp0 == MACH_PORT_NULL) {
        return ERR_TFP0;
    }
    
    tfpzero = tfp0;
    
    uint64_t kernel_base = find_kernel_base();
    
    // Loads the kernel into the patch finder, which just fetches the kernel memory for patchfinder use
    //init_kernel(kernel_base, NULL);
    init_kernel(kernel_base, NULL);
    // Get the slide
    uint64_t slide = kernel_base - 0xFFFFFFF007004000;
    printf("slide: 0x%016llx\n", slide);
    
    init_kexecute();
    kernel_slide_init();
    // Get our and the kernels struct proc from allproc
    
    uint32_t our_pid = getpid();
    printf("our_pid is %d\n", our_pid);
    //setuid(0);
    // 25. Next we can use the kernel task to get the address of the kernel vm_map.
    uint64_t kernel_map = MReadKernel64(kernel_task + OFFSET(task, map));
#define FAKE_TASK_SIZE 0x380

    //kernel_task_port = fake_port;
    // And that's it! Enjoy kernel read/write via kernel_task_port.
    printf("[*] kernel_task_port tfp0 : 0x%x\n", kernel_task_port);
    printf("[*] kernel_map! port : 0x%llx\n", kernel_map);
    printf("[*] cached_task_self_addr : 0x%llx\n", cached_task_self_addr);
    //remap_tfp0_set_hsp4(&tfpzero);
    //current_task();
    //current_thread();
    //fake_host_priv();
    //make_port_fake_task_port(tfp0, cached_task_self_addr);
    printf("our gid is %d\n", getgid());
    printf("our ppid is %d\n", getppid());
    printf("our shell is %s\n", getusershell());
    printf("our uid is %d\n", getuid());
    
    int rv2 = setuid(0);
    printf("setuid 0 check %d\n", rv2);
    printf("our gid is %d\n", getgid());
    printf("our ppid is %d\n", getppid());
    printf("our shell is %s\n", getusershell());
    printf("our uid is %d\n", getuid());
    //prepare_for_rw_with_fake_tfp0(tfp0);
    //find_rootvnode();
   // printf("find_rootvnode is %llx\n", find_rootvnode());
    uint64_t our_proc = (get_proc_struct_for_pid(our_pid));
    printf("our_proc is %llx\n", our_proc);
    uint64_t launchd_proc = (get_proc_struct_for_pid(1));
    printf("launchd_proc is %llx\n", launchd_proc);
    
    uint64_t kern_proc = (get_proc_struct_for_pid(9));
    
    printf("kern_proc is %llx\n", kern_proc);
    uint32_t amfid_pid = find_pid_of_proc("amfid");
    printf("amfid_pid is %d\n", amfid_pid);
    uint64_t amfid_proc = (get_proc_struct_for_pid(amfid_pid));//get_proc_struct_for_pid(amfid_pid);
    printf("amfid_proc is %llx\n", amfid_proc);
    uint32_t cfprefsd_pid = find_pid_of_proc("cfprefsd");
    printf("cfprefsd_pid is %d\n", cfprefsd_pid);
    
    if (!our_proc || !launchd_proc || !kern_proc || !amfid_proc) {
    //if (!our_proc) {

        err = ERR_JAILBREAK;
        goto out;
    }
  
    
   /* printf("our proc is at 0x%016llx\n", our_proc);
    printf("launchd proc is at 0x%016llx\n", launchd_proc);
    printf("kern proc is at 0x%016llx\n", kern_proc);
    printf("amfid proc is at 0x%016llx\n", amfid_proc);
    */
    uint32_t csflags;
    
    csflags = rk32(our_proc + offsetof_p_csflags);
    csflags = (csflags | CS_PLATFORM_BINARY | CS_INSTALLER | CS_GET_TASK_ALLOW) & ~(CS_RESTRICT | CS_HARD | CS_KILL);
    wk32(our_proc + offsetof_p_csflags, csflags);
    
    set_csblob(our_proc);
    
    csflags = rk32(launchd_proc + offsetof_p_csflags);
    wk32(launchd_proc + offsetof_p_csflags, (csflags | CS_PLATFORM_BINARY | CS_INSTALLER | CS_GET_TASK_ALLOW) & ~(CS_RESTRICT | CS_HARD));
    
    csflags = rk32(amfid_proc + offsetof_p_csflags);
    wk32(amfid_proc + offsetof_p_csflags, (csflags | CS_PLATFORM_BINARY | CS_INSTALLER | CS_GET_TASK_ALLOW) & ~(CS_RESTRICT | CS_HARD));
   
    if (find_pid_of_proc("jailbreakd")) {
        err = ERR_ALREADY_JAILBROKEN;
        goto out;
    }
    
    // Properly copy the kernel's credentials so setuid(0) doesn't crash
    uint64_t find_copyout(void);
    uint64_t copyout = find_copyout();
    uint64_t bcopy = find_bcopy();
    uint64_t bzero = find_bzero();
    
    uint64_t kern_ucred = 0;
    kexecute(copyout, kern_proc+offsetof_p_ucred, (uint64_t)&kern_ucred, sizeof(kern_ucred), 0, 0, 0, 0);
    
    uint64_t self_ucred = 0;
    kexecute(copyout, our_proc+offsetof_p_ucred, (uint64_t)&self_ucred, sizeof(self_ucred), 0, 0, 0, 0);
    
    kexecute(bcopy, kern_ucred + 0x78, self_ucred + 0x78, sizeof(uint64_t), 0, 0, 0, 0);
    kexecute(bzero, self_ucred + 0x18, 12, 0, 0, 0, 0, 0);
    
    setuid(0);
    if (getuid()) {
        err = ERR_JAILBREAK;
        goto out;
    }
    
    
    printf("our uid is %d\n", getuid());
    
    // Test writing to file
    {
        FILE *f = fopen("/var/mobile/test.txt", "w");
        if (f == 0) {
            //printf("failed to write test file");
        } else {
           // printf("wrote test file: %p\n", f);
        }
        
        unlink("/var/mobile/test.txt");
    }
    
    
    remap_tfp0_set_hsp4(&tfpzero);
    
    unlocknvram();
    
    //printf("Mounted volumes:\n");
    //printf("\n");
    
    int forkAndRunMount = fork();
    if (forkAndRunMount > 0){
        waitpid(forkAndRunMount, NULL, 0);
    } else if (forkAndRunMount == 0){
        const char *args_mount[] = {"mount", NULL};
        execv("/sbin/mount", (char **)&args_mount);
        //printf("Child should never reach here!\n");
        exit(-1);
    } else {
        //printf("Unable to fork!\n");
    }
    
    int ret;
    
    // Only set a generator if one is not already set or if the user has specified one
    const char *currentgen = getgen();
    if (!currentgen || userGenerator()) {
        const char *gen = genToSet();
        // Only actually set the generator if it is not already set
        if (!currentgen || strcasecmp(currentgen, gen) != 0) {
            //printf("Setting generator to %s\n", gen);
            ret = setgen(gen);
            //printf("ret: %d\n", ret);
        } else {
            //printf("Requested generator already set: %s\n", gen);
        }
    }
    
   // printf("nvram variables:\n");
    //printf("\n");
    
    int forkAndRunNVRAM = fork();
    if (forkAndRunNVRAM > 0){
        waitpid(forkAndRunNVRAM, NULL, 0);
    } else if (forkAndRunNVRAM == 0){
        const char *args_nvram[] = {"nvram", "-p", NULL};
        execv("/usr/sbin/nvram", (char **)&args_nvram);
        //printf("Child should never reach here!\n");
        exit(-1);
    } else {
        //printf("Unable to fork!\n");
    }
    
    locknvram();
    
    printf("APFS Snapshots: \n");
    printf("=========\n");
    int snapshot_success = list_snapshots("/");
    printf("=========\n");
    
    ret = remountRootAsRW(slide, kern_proc, our_proc, snapshot_success);
    
    if (ret != 0) {
        err = ERR_ROOTFS_REMOUNT;
        goto out;
    }
    
    copy_basebinaries();
    
    forkAndRunMount = fork();
    if (forkAndRunMount > 0){
        waitpid(forkAndRunMount, NULL, 0);
    } else if (forkAndRunMount == 0){
        const char *args_mount[] = {"mount", NULL};
        execv("/sbin/mount", (char **)&args_mount);
        printf("Child should never reach here!\n");
        exit(-1);
    } else {
        printf("Unable to fork!\n");
    }
    
    // dumpContentsOfDir("/");
    //dumpContentsOfDir("/electra");
    
#define BinaryLocation "/electra/inject_criticald"
    
    int rv;
    pid_t pd;
    
    const char* args_amfid[] = {BinaryLocation, itoa(amfid_pid), "/electra/amfid_payload.dylib", NULL};
    rv = posix_spawn(&pd, BinaryLocation, NULL, NULL, (char **)&args_amfid, NULL);
    waitpid(pd, NULL, 0);
    
    unlink("/.amfid_success");
    const char *args_helloworld[] = {"helloworld", NULL};
    rv = posix_spawn(&pd, "/electra/helloworld", NULL, NULL, (char **)&args_helloworld, NULL);
    waitpid(pd, NULL, 0);
    
    if (!file_exists("/.amfid_success")){
        printf("amfid injection fail!\n");
        return ERR_AMFID_PATCH;
    }
    unlink("/.amfid_success");
    
    //
    if (checkingJUSTremovecheck()==TRUE){
        int bootstrapped = open("/var/mobile/Media/.bootstrapped_electraRemover", O_RDONLY);
        printf("[*****] REMOVER working!\n");
        if (snapshot_success == 0 && kCFCoreFoundationVersionNumber <= 1451.51){
            if (bootstrapped == -1) {
                int snapshot = check_snapshot("/", "electra-prejailbreak");
                if (snapshot == 1){
                    printf("Snapshot exists!\n");
                } else if (snapshot == 0){
                    rename("/electra/createSnapshot", "/createSnapshot");
                    pid_t pd;
                    rmdir("/electra");
                    
                    rv = posix_spawn(&pd, "/createSnapshot", NULL, NULL, (char **)&(const char*[]){ "createSnapshot", NULL }, NULL);
                    waitpid(pd, NULL, 0);
                    
                    printf("APFS Snapshots: \n");
                    
                    printf("=========\n");
                    list_snapshots("/");
                    printf("=========\n");
                    
                    snapshot = check_snapshot("/", "electra-prejailbreak");
                    if (snapshot != 1){
                        err = ERR_SNAPSHOT;
                        goto out;
                    }
                    
                    acknowledgeSnapshotWarning = false;
                    displaySnapshotNotice();
                    while (!acknowledgeSnapshotWarning){
                        usleep(1000000);
                    }
                    
                    copy_basebinaries();
                }
            } else {
                int snapshot = check_snapshot("/", "electra-prejailbreak");
                if (snapshot != 1){
                    if (!file_exists("/.electra_no_snapshot")){
                        acknowledgeSnapshotWarning = false;
                        displaySnapshotWarning();
                        while (!acknowledgeSnapshotWarning){
                            usleep(1000000);
                        }
                        int rv = open("/.electra_no_snapshot", O_RDWR|O_CREAT);
                        close(rv);
                    }
                }
            }
        }
        
        close(bootstrapped);
        
    }else {
            int bootstrapped = open("/.bootstrapped_Th0r", O_RDONLY);
        
            if (bootstrapped == -1) {
                if (checkLiberiOS() == true) {
                    removingLiberiOS();
                    removeLiberiOS();
                }
    #if ELECTRADEBUG
    #else /* !ELECTRADEBUG */
                if (detectConflictJailbreak()) {
                    err = ERR_CONFLICT;
                    goto out;
                }
    #endif /* !ELECTRADEBUG */
                removePotentialJailbreak();
            }
        if (snapshot_success == 0 && kCFCoreFoundationVersionNumber <= 1451.51){
            if (bootstrapped == -1) {
                int snapshot = check_snapshot("/", "electra-prejailbreak");
                if (snapshot == 1){
                    printf("Snapshot exists!\n");
                } else if (snapshot == 0){
                    rename("/electra/createSnapshot", "/createSnapshot");
                    pid_t pd;
                    rmdir("/electra");
                    
                    rv = posix_spawn(&pd, "/createSnapshot", NULL, NULL, (char **)&(const char*[]){ "createSnapshot", NULL }, NULL);
                    waitpid(pd, NULL, 0);
                    
                    printf("APFS Snapshots: \n");
                    
                    printf("=========\n");
                    list_snapshots("/");
                    printf("=========\n");
                    
                    snapshot = check_snapshot("/", "electra-prejailbreak");
                    if (snapshot != 1){
                        err = ERR_SNAPSHOT;
                        goto out;
                    }
                    
                    acknowledgeSnapshotWarning = false;
                    displaySnapshotNotice();
                    while (!acknowledgeSnapshotWarning){
                        usleep(1000000);
                    }
                    
                    copy_basebinaries();
                }
            } else {
                int snapshot = check_snapshot("/", "electra-prejailbreak");
                if (snapshot != 1){
                    if (!file_exists("/.electra_no_snapshot")){
                        acknowledgeSnapshotWarning = false;
                        displaySnapshotWarning();
                        while (!acknowledgeSnapshotWarning){
                            usleep(1000000);
                        }
                        int rv = open("/.electra_no_snapshot", O_RDWR|O_CREAT);
                        close(rv);
                    }
                }
            }
        }
        
        close(bootstrapped);
        
        
        }
    


    
    printf("Running mount...\n");
    //rmounting();
    term_kexecute();
    //almostdone();
    extract_bootstrap();
    serverS();
    printf("Starting server...\n");
    //serverS();
    
    
    
    
    
    if (checkingJUSTremovecheck()==TRUE){
        
        printf("[*****] FUCK REMOVER IS GETTING CLOSER!\n");
        
        
    }else {
        ////////////////remover block
        start_jailbreakd(kernel_base);
        //wait4jailbreakd();
        while (!file_exists("/var/run/jailbreakd.pid")){
            //printf("Waiting for jailbreakd...\n");
            //sleep(2); //100 ms
            usleep(100000);//10 ms
            
        }
        
        ////////////////remover block
        
    }
    





    unlink("/electra/createSnapshot");
    unlink("/electra/rm");
    
    update_springboard_plist();
    //sleep(1);
    
    
    if (checkingJUSTremovecheck()==TRUE){
        
        printf("[*****] FUCK REMOVER IS GETTING CLOSER!\n");
        
        
    }else {
        ////////////////remover block
        kill(cfprefsd_pid, SIGKILL);
        ////////////////remover block
  
    }
    
    

    //waittermkernel();
    //waittermkernel();
    term_kernel();

    if (checkingJUSTremovecheck()==TRUE){
        
        printf("[*****] FUCK REMOVER IS GETTING CLOSER!\n");
        
        
    }else {
        ////////////////remover block
        
        while (!file_exists("/electra/pspawn_payload.dylib")){
            usleep(10);
        }
        //waitkerneldone();
        run(""BinaryLocation" 1 /electra/pspawn_payload.dylib");
        
        if (enable_tweaks){
            startdwait();
            startDaemons();
            posix_spawn(&pd, "/electra/killall", NULL, NULL, (char **)&(const char*[]){ "/electra/killall", "SpringBoard", NULL }, NULL);
            //   posix_spawn(&pd, "/electra/killall", NULL, NULL, (char **)&(const char*[]){ "/electra/killall", "backboardd", NULL }, NULL);
            waitpid(pd, NULL, 0);
            
        }
        ////////////////remover block
    }

    /////////
    return err;
out:
    term_kexecute();
    term_kernel();
    return err;
}
